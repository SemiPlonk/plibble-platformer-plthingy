function init(self)
	msg.post(".", "acquire_input_focus")
	self.velocity = 0
	self.acceleration = 250
	--acceleration changed by water interactions
	self.max_speed = 300
	self.friction = 300
	self.left_pressed = false
	self.right_pressed = false
	self.input_dir = 0

	self.right_contact = false
	self.right_contactV = false
	self.left_contact = false
	self.left_contactV = false
	self.roof_contact = false

	self.Yvelocity = 0
	self.Gravity = 200
	self.jumping = false
	self.ground_contact = false
	self.walljumpmodifier = 1
	self.alive = true

	self.doorused = false

	_G.playercam = true
	_G.player_pos = go.get_position()
	_G.CamActive = true
	_G.door = false
end

function on_input(self, action_id, action)
	-- figurin' out what keys ya pressed, loser.
	if action_id == hash("PMLeft") then
		if action.pressed or action.repeated then
			self.left_pressed = true
		elseif action.released then
			self.left_pressed = false
		end
	elseif action_id == hash("PMRight") then
		if action.pressed or action.repeated then
			self.right_pressed = true
		elseif action.released then
			self.right_pressed = false
		end
	elseif action_id == hash("Jump") then
		self.jumping = true
		
	elseif action_id == hash("Up") then
		self.doorused = true
	end
end


function on_message(self, message_id, message, sender)
	-- find out if player is touching the floor
	if message_id == hash("contact_point_response")
	and message.other_group == hash("ground") then
		self.ground_contact = true
		self.walljumpmodifier = 1
	end

	-- find out if player is touching wall
	if message_id == hash("contact_point_response")
	and message.other_group == hash("L-Wall") then
		self.left_contact = true
		self.left_contactV = true
	end
	
	if message_id == hash("contact_point_response")
	and message.other_group == hash("R-Wall") then
		self.right_contact = true
		self.right_contactV = true
	end
	
	if message_id == hash("contact_point_response")
	and message.other_group == hash("Roof") then
		self.roof_contact = true
	end

	-- ok so what if it was the same as the other ones... but with water?
	if message_id == hash("collision_response")
	and message.other_group == hash("water") then
		self.inwater = true
	end

	-- enemy hit detection
	if message_id == hash("collision_response")
	and message.other_group == hash("enemy") then
		if self.alive == true then
			_G.CamActive = false
			self.alive = false
			msg.post("Spawnpoint#Player spawning", "death")
			go.delete()
		end
	end

	if message_id == hash("collision_response")
	and message.other_group == hash("door") then
		_G.door = true
	end

	-- enemy bounce detection
	if message_id == hash("collision_response")
	and message.other_group == hash("e-head") then
		self.Yvelocity = 75
		if self.jumping == true then
			if self.Yvelocity <= 0 then
				self.Yvelocity = self.Yvelocity + 225
			else
				self.Yvelocity = 225
			end
		else
			self.Yvelocity = 75
		end
	end

	-- add something about lives here at some stage

end

function update(self, dt)
	-- Determine input_dir based on keys currently pressed
	if self.left_pressed and not self.right_pressed then
		self.input_dir = -1
	elseif self.right_pressed and not self.left_pressed then
		self.input_dir = 1
	else
		self.input_dir = 0
	end

	if self.input_dir ~= 0 then
		
		-- pulling against speed slows down more
		if (self.velocity > 0 and self.input_dir == -1) or (self.velocity < 0 and self.input_dir == 1) then
			-- decelerate faster (use acceleration as braking force)
			self.velocity = self.velocity + self.input_dir * self.acceleration * 2 * dt
		else
			
			-- accelerate normally
			local tempspeed = self.velocity + self.input_dir * self.acceleration * dt
			if tempspeed > self.max_speed or tempspeed < -self.max_speed then
				self.velocity = self.velocity
			else
				self.velocity = tempspeed
			end
		end
	else
		-- on the ground
		if self.Yvelocity == 0 then
			--   in the air
			if self.velocity > 2 then
				self.velocity = self.velocity - self.friction * dt
			elseif self.velocity < -2 then
				self.velocity = self.velocity + self.friction * dt
			else
				self.velocity = 0
			end
			--slow down if on ground and over max speed
			if self.velocity > self.max_speed then
				self.velocity = self.velocity - 50 * dt
			elseif self.velocity < -self.max_speed then
				self.velocity = self.velocity + 50 * dt
			end
		else
			--   in the air
			if self.velocity > 2 then
				self.velocity = self.velocity - self.friction * dt * 0.6
			elseif self.velocity < -2 then
				self.velocity = self.velocity + self.friction * dt * 0.6
			else
				self.velocity = 0
			end

			
		end
	end

	
	--wall collisions
	if self.left_contact then
		if self.velocity < 0 then
			self.velocity = 0
		end
	end
	
	if self.right_contact then
		if self.velocity > 0 then
			self.velocity = 0
		end
	end

	--Wall jumping!
	if self.right_contact and self.jumping then
		self.jumping = false
		self.velocity = -150 * self.walljumpmodifier
		self.Yvelocity = self.Yvelocity + 100 / (self.walljumpmodifier * 0.9)
		self.walljumpmodifier = self.walljumpmodifier * 1.33
	end
	if self.left_contact and self.jumping then
		self.jumping = false
		self.velocity = 150 * self.walljumpmodifier
		self.Yvelocity = self.Yvelocity + 100 / (self.walljumpmodifier * 0.9)
		self.walljumpmodifier = self.walljumpmodifier * 1.33
	end
	if self.walljumpmodifier > 3 then
		self.walljumpmodifier = 3
	end

	_G.player_pos = go.get_position()
	local pos = go.get_position()
	pos.x = pos.x + self.velocity * dt
	go.set_position(pos)
	self.left_contact = false
	self.right_contact = false

end

function fixed_update(self, dt)

	-- wow you have functional legs
	--(jump)
	if self.jumping and self.ground_contact then
		self.Yvelocity = 150
	end


	
	if self.inwater then
		self.Yvelocity = self.Yvelocity - (self.Gravity * 0.4) * dt
		self.inwater = false

	--Wall sliding/boosting
	elseif self.left_contactV or self.right_contactV then
		if self.Yvelocity < -50 then
			self.Yvelocity = self.Yvelocity - (self.Gravity * 0.3) * dt
			if self.Yvelocity < -100 then
				self.Yvelocity = self.Yvelocity + 3
			end
		else
			self.Yvelocity = self.Yvelocity - self.Gravity * dt
		end
		
	else
		self.Yvelocity = self.Yvelocity - self.Gravity * dt
	end

	
	if self.ground_contact then
		if self.Yvelocity <= 0 then
			self.Yvelocity = 0
		end
	end

	if self.roof_contact then
		if self.Yvelocity >= 0 then
			self.Yvelocity = 0
		end
	end

	local pos = go.get_position()
	pos.y = pos.y + self.Yvelocity * dt
	go.set_position(pos)

	if self.doorused == true and _G.door == true then
		_G.newlevel = true
	end

	-- This solves like every issue
	self.ground_contact = false
	self.roof_contact = false
	self.jumping = false
	self.right_contactV = false
	self.left_contactV = false
	self.doorused = false
	_G.door = false
end